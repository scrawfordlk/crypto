\input{../preamble}
\usepackage[naustrian]{babel}

\begin{document}
\maketitle

\section{Implementierung der Baker Map}
% \lstinputlisting[style=pythonstyle, caption=This is code]{test.py}

\section{Chaos-basierte Bildverschlüsselung und Entschlüsselung}
\subsection{Motivation}
% TODO: 
TODO: Main motivations from his article: less computational effort (than AES) and more security benefits.

Für die Verschlüsselung von Bildern wird eine Methode benötigt, die den Inhalt
versteckt. Bilder bestehen aus einer Struktur von Pixeln, d.h. es ist relevant welche Pixel neben welchen
Pixeln liegen. Weiters weisen Bilder eine hohe Redundanz auf. Traditionelle Verschlüsselungsmethoden beachten
diese Aspekte bei Bildern nicht wirklich und somit ist eine andere Verschlüsselungsmethode erforderlich.
Chaos-basierte Verschlüsselung ist deterministisch, hat eine hohe Ergodizidät, d.h. es werden praktisch alle
möglichen Zustände des Systems über einen längeren Zeitraum angenommen, und weist Pseudo-Zufälligkeit auf. Außerdem
sind sie sehr sensibel zu den Ausgangsbedingungen, d.h. kleine Veränderungen der Ausgangsbedingungen führen zu
sehr anderen Ergebnissen. Das bedeutet, dass aufgrund der Komplexität solcher Systeme es schwer ist,
das Verhalten vorherzusehen.
Somit sind chaos-basierte Verschlüsselungen von Vorteil für die Verschlüsselung von Bildern.
\cite{zhang2023}

\subsection{Funktionsweise}
Die chaos-basierte Verschlüsselung nutzt eine chaotische Abbildung wie die Baker Map oder Cat Map. Beide bilden
einen 2-dimensionalen Einheitsquadrat auf sich selber ab. Der Grund warum diese Abbildungen gewählt werden ist, da
sie relativ simpel sind und somit schnell verschlüsselt/enschlüsselt werden kann. 
Eine solche Abbildung wird dann im nächsten Schritt generalisiert, indem Parameter zur Abbildung hinzugefügt werden.
Danach wird sie diskretisiert, denn ein Bild besteht aus diskreten Pixeln. Das bedeutet, dass die Abbildung so
modifiziert wird, sodass sie nicht mehr ein Einheitsquadrat auf sich selbst abbilden, sondern ein 2-dimensionales quadratisches
Bild bestehend aus Pixeln auf sich selber abbildet. So eine Abbildung bestimmt also eine Bijektion zwischen den einzelnen Pixeln
quadratischer Bilder, sodass eine Permutation der Pixel berechnet werden kann. Anschließend wird die Abbildung auf 3 Dimensionen erweitert,
sodass einzelne Pixel Werte modifiziert werden. Schlussendlich wird dann eine Diffusion noch angewendet als Komposition zur bestehenden
Abbildung.
\cite{IEEEMap}

Zur Entschlüsselung wird dann die inverse Baker Map verwendet, sodass man das Ursprungsbild wieder erhaltet nach gleich vielen Iterationen.

\subsubsection{Baker Map}
Die Baker Map ist eine chaotische Abbildung des Einheitsquadrates $I \times I$ auf sich selbst, die formell folgendermaßen beschrieben wird:
$$B(x, y) = (2x, \frac{y}{2}) \text{ if }  0 \leq x < \frac{1}{2}$$
$$B(x, y) = (2x - 1, \frac{y + 1}{2}) \text{ if } \frac{1}{2} \leq x \leq 1$$
Wobei $x$ und $y$ die Koordinaten sind.
In Worten ist die Baker Map eine Abbildung, die einen Einheitsquadrat so auf sich selbst abbildet: Als erstes wird er vertikal in zwei Rechtecken
aufgeteilt. Dann werden diese langgestreckt, sodass die Höhe sich halbiert. Anschließend wird eine der Hälften auf die andere gelegt. Diesen
Prozess kann man mit der Arbeit eines Bäckers beim Kneten von Teig vergleichen, daher der Name.
\cite{IEEEMap}

\subsubsection{Cat Map}
Die standard Cat Map, die ein quadratisches Bild $N \times N$ auf sich selbst abbildet, ist folgendermaßen definiert:
$$
	\begin{bmatrix} x' \\ y' \end{bmatrix} =
	\begin{bmatrix} 1 & 1 \\ 1 & 2 \end{bmatrix}
	\begin{bmatrix} x \\ y \end{bmatrix} (\mod N)
$$
Wobei $x, y \in \{0, 1, \dots , N - 1 \}$, $(x, y)$ ist ein Pixel des Originalbildes und $(x', y')$ ist das abgebildete Pixel.
\cite{catmap}

\section{Verschlüsselung mit AES}
Für die Verschlüsselung wurde PyCryptdome verwendet.
Dies ist der Programmcode, für die Verschlüsselungsfunktion:
\begin{lstlisting}
import cv2
from Crypto.Cipher import AES

def encrypt_image(key, image):
    width, height = image.shape
    flat_original = image.flatten()
    flat_encrypted = flat_original.copy()
    ivs = []

    for i in range(0, len(flat_original), 16):
        cipher = AES.new(key, AES.MODE_CBC)
        ivs.append(cipher.iv)
        pixels = flat_original[i : i + 16]

        encrypted_bytes = cipher.encrypt(b"".join(pixels))
        for j in range(16):
            flat_encrypted[i + j] = encrypted_bytes[j]

    encrypted_image = flat_encrypted.reshape((width, height))
    return ivs, encrypted_image
\end{lstlisting}
Die Funktion \lstinline{encrypt_image()} besitzt zwei Parameter: einen Schlüssel und das Bild,
das man verschlüsseln möchte. Als Erstes werden die Seitenlängen des Bildes gespeichert. Dann wird das 2D-Bild-Array
mit \lstinline{.flatten()} zu einem 1D-Array umgewandelt für leichtere Handhabung. Außerdem wird ein weiteres 1D-Array
gleicher Länge angelegt, wo die verschlüsselten Pixel später platziert werden.

In den Zeilen 10 bis 17 ist dann der Hauptalgorithmus. Für jede 16 Elemente des 1D-Arrays wird ein neuer Cipher erstellt,
dessen Initialisierungsvektor \lstinline{iv} in die \lstinline{ivs} Liste gespeichert wird. Anschließend werden die 16 Elemente,
also 16 Bytes, zu einem 16-Byte-Block (128-Bit) zusammengeführt und mithilfe dem Cipher verschlüsselt.
Dann wird an jene Stellen, von denen die ursprünglichen Bytes kommen, die verschlüsselten
16 Bytes als verschlüsselte Pixel in das neue 1D-Array gesetzt. Nachdem der äußerste for-loop terminiert, wird das neu befüllte 1D-Array in ein
Bild umgewandelt, welches dann mit \lstinline{ivs} als 2-Tupel zurückgegeben wird.

Zum Entschlüsseln benötigt man denselben Schlüssel und die Initialisierungsvektoren. Die Funktion dazu ist diese hier:
\begin{lstlisting}
def decrypt_image(ivs, key, image):
    width, height = image.shape
    flat_encrypted = image.flatten()
    flat_decrypted = flat_encrypted.copy()

    for i in range(0, len(flat_encrypted), 16):
        cipher = AES.new(key, AES.MODE_CBC, iv=ivs[i // 16])
        pixels = flat_encrypted[i : i + 16]

        decrypted_bytes = cipher.decrypt(b"".join(pixels))
        for j in range(16):
            flat_decrypted[i + j] = decrypted_bytes[j]

    return flat_decrypted.reshape((width, height))
\end{lstlisting}
Der Algorithmus ist analog zu \lstinline{encrypt_image()}. Die 2D-Arrays werden in 1D-Arrays umgewandelt. Dann wird für alle
16 Bytes diese 16 Bytes mithilfe des Schlüssels und dem jeweiligen Initialisierungsvektor entschlüsselt. Anschließend werden diese entschlüsselten Bytes
bei dem neuen 1D-Array entsprechend ihrer ursprünglichen Positionen gesetzt. Als Letztes wird dann dieses entschlüsselte 1D-Array
in ein 2D-Bild-Array zurückgewandelt und man hat somit das verschlüsselte Bild entschlüsselt.

Somit könnte das Hauptprogramm folgendermaßen vorgehen:
\begin{lstlisting}
def main():
    image = cv2.imread(sys.argv[1])
    image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    show_image_with_entropy(image)

    cipher_key = b"my 16 byte key!!"
    ivs, encrypted_image = encrypt_image(cipher_key, image)
    show_image_with_entropy(encrypted_image)

    decrypted_image = decrypt_image(ivs, cipher_key, encrypted_image)
    show_image_with_entropy(decrypted_image)
\end{lstlisting}
Der Name des Bildes wird als command-line Argument übergeben. Es wird dann eingelesen und in Grayscale konvertiert.
Dann wird mit dem key \lstinline{cipher_key} das Bild verschlüsselt mithilfe \lstinline{encrypt_image()} und danach
mit demselben Schlüssel und den erhaltenen Initialisierungsvektoren mit der Funktion \lstinline{decrypt_image()} entschlüsselt.

\subsection{Verschlüsseln von 10 Bildern}
Für konkrete Beispiele mit den jeweiligen Entropien, siehe Abbildungen \ref{fig:cat} bis \ref{fig:sky}.

\subsection{Zeitbedarf der Verschlüsselung}
Was den Zeitbedarf der Verschlüsselung betrifft: Die Ausführung des Programms dauert im Durchschnitt
$613.79$ Millisekunden.
Die Tabelle \ref{tab:speed3} gibt die konkreten Werte pro Bild an, wobei die Nummerierungen der Bilder
der Ordnung der Bilder entsprechen.
\begin{table}
	\begin{center}
		\begin{tabular}{ |c|c|c| } 
		\hline
		Bild & Zeit (in Millisekunden) \\
		\hline
		1 & 623.05 \\
		2 & 598.61 \\
		3 & 617.41\\
		4 & 598.53\\
		5 & 603.35\\
		6 & 605.35\\
		7 & 620.01\\
		8 & 608.46\\
		9 & 636.87\\
		10 & 626.23\\
		\hline
		\end{tabular}
	\end{center}
	\caption{Die individuellen Zeiten um ein Bild zu verschlüsseln}
	\label{tab:speed3}
\end{table}

\begin{figure}
	\centering

	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/gray_7.055047578254635_cat.jpg}
		\caption{Entropie: 7.055047578254635}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/encrypted_7.9993452182261775_cat.jpg}
		\caption{Entropie: 7.999345218226177}
	\end{subfigure}

	\caption{Bild vor (a) und nach (b) Verschlüsselung}
	\label{fig:cat}
\end{figure}

\begin{figure}
	\centering

	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/gray_5.489817933250877_flower.jpg}
		\caption{Entropie: 5.489817933250877}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/encrypted_7.999288647342163_flower.jpg}
		\caption{Entropie: 7.999288647342163}
	\end{subfigure}

	\caption{Bild vor (a) und nach (b) Verschlüsselung}
	\label{fig:flower}
\end{figure}

\begin{figure}
	\centering

	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/gray_6.176106420718194_meme_man.png}
		\caption{Entropie: 6.176106420718194}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/encrypted_7.999330312791573_meme_man.png}
		\caption{Entropie: 7.999330312791573}
	\end{subfigure}

	\caption{Bild vor (a) und nach (b) Verschlüsselung}
	\label{fig:meme_man}
\end{figure}

\begin{figure}
	\centering

	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/gray_1.968975268089162_spheal.png}
		\caption{Entropie: 1.968975268089162}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/encrypted_7.999276890528033_spheal.png}
		\caption{Entropie: 7.999276890528033}
	\end{subfigure}

	\caption{Bild vor (a) und nach (b) Verschlüsselung}
	\label{fig:spheal}
\end{figure}

\begin{figure}
	\centering

	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/gray_4.1555418953746175_frog.jpg}
		\caption{Entropie: 4.155541895374617}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/encrypted_7.999333134306007_frog.jpg}
		\caption{Entropie: 7.999333134306007}
	\end{subfigure}

	\caption{Bild vor (a) und nach (b) Verschlüsselung}
	\label{fig:frog}
\end{figure}

\begin{figure}
	\centering

	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/gray_6.761302835772753_synthwave.jpg}
		\caption{Entropie: 6.761302835772753}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/encrypted_7.999245942902867_synthwave.jpg}
		\caption{Entropie: 7.999245942902867}
	\end{subfigure}

	\caption{Bild vor (a) und nach (b) Verschlüsselung}
	\label{fig:synthwave}
\end{figure}

\begin{figure}
	\centering

	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/gray_7.2193250947721515_fantasy_tree.jpg}
		\caption{Entropie: 7.219325094772151}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/encrypted_7.999253958586079_fantasy_tree.jpg}
		\caption{Entropie: 7.999253958586079}
	\end{subfigure}

	\caption{Bild vor (a) und nach (b) Verschlüsselung}
	\label{fig:fantasy}
\end{figure}

\begin{figure}
	\centering

	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/gray_7.228465731556658_city.jpg}
		\caption{Entropie: 7.228465731556658}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/encrypted_7.999299251892032_city.jpg}
		\caption{Entropie: 7.999299251892032}
	\end{subfigure}

	\caption{Bild vor (a) und nach (b) Verschlüsselung}
	\label{fig:city}
\end{figure}

\begin{figure}
	\centering

	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/gray_6.920844020928125_pikachu.jpg}
		\caption{Entropie: 6.920844020928125}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/encrypted_7.999437945674354_pikachu.jpg}
		\caption{Entropie: 7.999437945674354}
	\end{subfigure}

	\caption{Bild vor (a) und nach (b) Verschlüsselung}
	\label{fig:pika}
\end{figure}

\begin{figure}
	\centering

	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/gray_6.636128377207226_planet_sky.jpg}
		\caption{Entropie: 6.636128377207226}
	\end{subfigure}
	\hfill
	\begin{subfigure}{0.35\textwidth}
		\includegraphics[width=\textwidth]{../1/3/encrypted_7.999257183679586_planet_sky.jpg}
		\caption{Entropie: 7.999257183679586}
	\end{subfigure}

	\caption{Bild vor (a) und nach (b) Verschlüsselung}
	\label{fig:sky}
\end{figure}


\section{Artikel: Deprecating Motivation and Empirical Security Analysis of Chaos-based Image and Video Encryption}
Im Artikel \cite{chaos}
Main Motivationen für chaos-basierte Verschlüsselung wird in Frage gestellt. (less computational effort (than eg. AES) and security benefits)
=> chaos-basierte Bildverschlüsselung ist nicht wirklich besser als traditionelle Methoden.

\subsection{Reduzierter Rechenaufwand}
Sie zeigen in einem Experiment, dass dies nicht der Fall ist und dass chaos-basierte Verschlüsselung sogar
mehr Rechenaufwand aufweisen kann. Verglichen wurden die populärsten chaos-basierten Bildverschlüsselungen, die sie
selber implementiert haben, mit
konventionellen AES Verschlüsselungen aus Libraries. Sie glauben sogar, dass chaos-basierte Verschlüsselung nicht einmal die Effizienz von
traditionellen Methoden erreichen kann.

\subsection{Security Vorteile}



\section{Fehlerkorrektur mit Hammingcodes}
\subsection{Funktionsweise}
\subsection{Beispiel}

\bibliography{lit}
\bibliographystyle{alpha}
\end{document}
